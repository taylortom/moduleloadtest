const Events = require('./events');
const fs = require('fs-extra');
const glob = require('glob');
const path = require('path');
const util = require('util');
const Utils = require('./utils');

const globPromise = util.promisify(glob);
/**
* Handles the loading of Adapt authoring tool module dependencies.
*/
class DependencyLoader extends Events {
  /**
  * @param {Object} app The main app instance
  */
  constructor(app) {
    super();
    /**
    * Name of the class (onvenience function to stay consistent with other classes)
    * @type {String}
    */
    this.name = this.constructor.name;
    /**
    * Reference to the main app
    * @type {App}
    */
    this.app = app;
    /**
    * Key/value store of dependent modules and their root path
    * @type {Object}
    */
    this.dependencies = {};
    /**
    * List of dependency instances
    * @type {object}
    */
    this.instances = {};
  }
  /**
  * Loads all dependencies
   @emits {initialised} Emits event on all modules initialised
  */
  async load() {
    const errors = [];
    const installedMods = await globPromise('node_modules/**/adapt.json');
    // helpers
    const getModRoot = p => path.join(process.cwd(), p.replace(`${path.sep}adapt.json`, ''));
    const getModName = p => p.split(path.sep).pop();

    for(let i = 0, count = installedMods.length; i < count; i++) {
      const modRoot = getModRoot(installedMods[i]);
      try {
        await this.loadModule(modRoot);
      } catch(e) {
        errors.push(e);
      }
    }
    if(errors.length) {
      this.throwError('error.loadfailed', { errors });
    }
    return;
  }
  async loadModule(modRoot) {
    const modConfig = {
      ...(await fs.readJson(path.join(modRoot, 'package.json'))),
      ...(await fs.readJson(path.join(modRoot, 'adapt.json'))),
      rootDir: modRoot
    };
    let ModClass, instance;
    try {
      ModClass = require(modConfig.name);
    } catch(e) {
      this.throwError('error.importmodule', { filepath: modRoot });
    }
    if(ModClass.Module) {
      ModClass = ModClass.Module;
    }
    if(!Utils.isFunction(ModClass)) {
      this.throwError('error.expectedclass', { name: modConfig.name });
    }
    try {
      instance = new ModClass(this.app, modConfig);
    } catch(e) {
      this.throwError('error.createmodule', { name: modConfig.name });
    }
    if(!Utils.isFunction(instance.onReady)) {
      this.throwError('error.expectedonready', { name: modConfig.name });
    }
    this.instances[modConfig.name] = instance;
    return;
  }
  /**
  * Retrieves a loaded module by name (if module name begins with 'adapt-authoring', this can be omitted)
  * @param {String} name Name of the Module
  * @return {AbstractModule} module instance
  * @example
  * App.instance.dependencyloader.getModule('adapt-authoring-myModule');
  * // or
  * App.instance.dependencyloader.getModule('myModule');
  */
  getModule(name) {
    return this.modules[name] || this.modules[`adapt-authoring-${name}`];
  }
  /**
  * Deals with errors during initialisation (we can't guarantee there's a Logger module at this point, so just emit an event)
  * @param {String} key Lang key
  * @param {Object} data Data to be passed to the error class
  * @param {String} type Type of error
  * @throws {DependencyLoaderError}
  */
  throwError(key, data, type = 'error') {
    throw new DependencyLoaderError(key, data, type);
  }
}
/**
* DependencyLoader Error
*/
class DependencyLoaderError extends Error {
  /**
  * @constructor
  * @param {String} key Language key to be used for main error message
  * @param {Object} data Data to be stored alongside error
  * @param {String} type Type of error (error, warn)
  */
  constructor(key, data, type) {
    super();
    /**
    * Language key to be used for main error message
    * @type {String}
    */
    this.key = key;
    /**
    * Data associated with the error
    * @type {Object}
    */
    this.data = data;
    /**
    * Type of error
    * @type {String}
    */
    this.type = type;
  }
}

module.exports = DependencyLoader;
